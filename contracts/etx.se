# etx.se -- Ethereum contract
#
# Copyright (c) 2014-2015 EtherEx
#
# This software may be modified and distributed under the terms
# of the MIT license.  See the LICENSE file for details.

#
# ETX subcurrency
#

data creator
data exchange
data total
data accounts[2^160](balance, custodians[2^160](full, maxValue))

event Transfer(from:indexed, to:indexed, value)
event AddressApproval(address:indexed, proxy:indexed, result)
event AddressApprovalOnce(address:indexed, proxy:indexed, value)

# Boolean success/failure
macro SUCCESS: 1
macro FAILURE: 0

macro MINIMUM_VALUE_NOT_MET: 2

def init():
    self.creator = msg.sender

# Set exchange contract address for ETX issuance
def setExchange(_address):
    if _address <= 0:
        return(FAILURE)

    if msg.sender == self.creator or msg.sender == self.exchange:
        self.exchange = _address
        return(SUCCESS)

    return(FAILURE)

# Issue ETX
def issue(_value, _address):
    if msg.sender == self.exchange:
        self.total += _value
        self.accounts[_address].balance += _value
        return(SUCCESS)
    return(FAILURE)

def reward(_amount):
    balance = self.accounts[msg.sender].balance

    if balance < _amount:
        return(FAILURE)

    share = (balance * 10 ^ 18) / self.total
    value = (self.balance * share) / 10 ^ 18

    if value > 10 ^ 18:
        self.accounts[msg.sender].balance -= _amount
        self.total -= _amount
        send(msg.sender, value)
        return(value)

    return(MINIMUM_VALUE_NOT_MET)

def transfer(_value, _to):
    # Prevent negative send from stealing funds
    if _to <= 0 or _value <= 0:
        return(FAILURE)

    # Get user balance
    balance = self.accounts[msg.sender].balance

    # Make sure balance is above or equal to amount
    if balance >= _value:

        # Update balances
        self.accounts[msg.sender].balance = balance - _value
        self.accounts[_to].balance += _value

        log(type=Transfer, msg.sender, _to, _value)

        return(SUCCESS)
    return(FAILURE)

def transferFrom(_from, _value, _to):
    # Prevent negative send from stealing funds
    if _from <= 0 or _value <= 0 or _to <= 0:
        return(FAILURE)

    # Get user balance
    balance = self.accounts[_from].balance

    # Make sure balance is above or equal to amount, and transfer is approved
    maxValue = self.accounts[_from].custodians[msg.sender].maxValue
    if balance >= _value and (self.accounts[_from].custodians[msg.sender].full or _value <= maxValue):
        # Update balances
        self.accounts[_from].balance = balance - _value
        self.accounts[_to].balance += _value

        # Reset approveOnce
        if maxValue:
            self.accounts[_from].custodians[msg.sender].maxValue = 0

        log(type=Transfer, _from, _to, _value)

        return(SUCCESS)
    return(FAILURE)

def balance(_addr):
    return(self.accounts[msg.sender].balance)

def balanceOf(_addr):
    return(self.accounts[_addr].balance)

def approve(_addr):  # Implemented but unused and untested
    self.accounts[msg.sender].custodians[_addr].full = 1
    log(type=AddressApproval, msg.sender, _addr, 1)
    return(SUCCESS)

# Returns whether _proxy is allowed full custody of your account
def isApproved(_proxy):
    return(self.accounts[msg.sender].custodians[_proxy].full)

# Returns whether _proxy is allowed full custody of _target account
def isApprovedFor(_target, _proxy):
    return(self.accounts[_target].custodians[_proxy].full)

# Approve _addr once for a transfer of _maxValue
def approveOnce(_addr, _maxValue):
    self.accounts[msg.sender].custodians[_addr].maxValue = _maxValue
    log(type=AddressApprovalOnce, msg.sender, _addr, _maxValue)
    return(1)

# Verify _proxy is approved to make a one-time transfer, if so returns _maxValue
def isApprovedOnce(_proxy):
    value = self.accounts[msg.sender].custodians[_proxy].maxValue
    if value > 0:
        return(value)
    return(0)

# Verify _proxy is approved to make a one-time transfer for _target address,
# if so returns _maxValue
def isApprovedOnceFor(_target, _proxy):
    value = self.accounts[_target].custodians[_proxy].maxValue
    if value > 0:
        return(value)
    return(0)

# Unapprove full and one-time custody of your account by _addr
def unapprove(_addr):
    self.accounts[msg.sender].custodians[_addr].full = 0
    self.accounts[msg.sender].custodians[_addr].maxValue = 0
    log(type=AddressApproval, msg.sender, _addr, 0)
    log(type=AddressApprovalOnce, msg.sender, _addr, 0)
    return(SUCCESS)
