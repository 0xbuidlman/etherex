# etherex.se -- Ethereum contract
#
# Copyright (c) 2014 EtherEx
#
# This software may be modified and distributed under the terms
# of the MIT license.  See the LICENSE file for details.

#
# EtherEx
#

init:
    # c3D definitions
    contract.storage[10] = 585546221243 # 0x88554646BB
    contract.storage[15] = msg.sender
    contract.storage[16] = msg.sender
    contract.storage[17] = block.timestamp

code:
    # Basic gas check
    if tx.gas < 1000:
        return(0) // "Insufficient gas"

    # Get our status
    status = contract.storage[1]

    # Get reference to owner / DOUG
    owner = contract.storage[15]

    # Get markets count
    cmarket = contract.storage[7]

    # Logging
    contract.storage[20] = msg.datasize
    contract.storage[21] = tx.gas

    # Operate only if initialized
    if status == 1:

        #
        # Basic checks
        #
        if msg.datasize < 1: // "No data to process"
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(0)

        if msg.data[0] < 1 or msg.data[0] > 10: // "Invalid operation"
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(2)

        # Add Buy / Sell trade checks
        if msg.data[0] < 3: // "Missing amount"
            if msg.datasize < 2:
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(3)

            elif msg.data[1] < 1: // "Invalid amount"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(4)

            elif msg.datasize < 3: // "Missing price"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(5)

            elif msg.data[2] < 1 * 10 ^ 8: // "Invalid price"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(6)

            elif msg.datasize < 4: // "Missing market ID"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(7)

            elif msg.data[3] > cmarket or msg.data[3] < 1: // "Invalid market ID"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(8)

            if msg.datasize > 4: // "Too many arguments"
                if msg.value > 0: // "Refunding"
                    ret = send(msg.sender, msg.value)
                return(9)

        #
        # Initialize markets
        #
        markets = contract.storage[6]

        # Get our request amount and price
        amount = msg.data[1] // "Trade amount: %d" % amount
        price = msg.data[2] // "Trade price: %d" % price

        # Basic amount and price checks
        if msg.data[0] < 3 and amount > 2^254: # or amount < 1:
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(10) // "Amount out of range"

        if msg.data[0] < 3 and price > 2^254: # or price < 1 * 10 ^ 8 + 1:
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(11) // "Price out of range"

        # Buy / Sell actions
        if msg.data[0] < 3:
            market = array(4)
            marketid = msg.data[3]

            # Get market
            market = call(markets, [marketid], 1, 4)

            # Checking trade amounts and balances
            if msg.data[0] == 1: # Check buy amount
                if amount < market[1]:
                    if msg.value > 0: // "Refunding"
                        ret = send(msg.sender, msg.value)
                    return(12) // "Minimum %s trade amount not met, minimum is %s, got %d" % (market[0], market[2], msg.value)
            else: # Check sell amount
                if msg.value < market[1]:
                    return(13) // "Minimum %s value not met, minimum is %s, got %d" % (market[0], market[2], msg.value)

                # Check msg.value and amount match
                if msg.value < amount:
                    if msg.value > 0: // "Refunding"
                        ret = send(msg.sender, msg.value)
                    return(14) // "Trade amount mismatch"

                # Refund excess value
                if msg.value > amount:
                    ret = send(msg.sender, msg.value - amount)


            # "Trade amounts OK for %s" % market[0]
            pricekey = price
            balances = market[3] // "TODO - Check %s balances" % market[0]
            indexes = contract.storage[4]
            trades = contract.storage[5]

            # New trade
            trade = array(5)
            trade[0] = 1
            trade[1] = msg.data[0]
            trade[2] = price
            trade[3] = amount
            trade[4] = msg.sender
            trade[5] = marketid

            tradeid = call(trades, trade, 6) # Trade added
            contract.storage[9] = tradeid
            booklength = (tradeid - 100) / 5 + 1
            # contract.storage[pricekey] = booklength
            contract.storage[100 + marketid] = booklength

            #
            # XETH issuance
            #
            xeth = array(4)

            # Get market
            xeth = call(markets, [1], 1, 4)

            reward = ((amount * price) / (1 * 10 ^ 21)) / 100 // "Sending reward of %s to %s" % (reward, msg.sender)
            data = array(2)
            data[0] = msg.sender
            data[1] = reward
            ret = msg(tx.gas - 25, xeth[3], reward, data, 2) // #define xethaddr=XETH

            return(tradeid)

        #
        # Trade
        #
        elif msg.data[0] == 3: // "TRADE"
            # t = 0
            # tc = msg.datasize - 1
            # while t < tc:
            #     t = t + 1
            #     trades[t] = msg.data[t]
            return(1)

        #
        # Deposit
        #
        elif msg.data[0] == 4: // "DEPOSIT"
            market = array(4)
            marketid = msg.data[1]

            # Get market
            market = call(markets, [marketid], 1, 4)

            data = array(2)
            data[0] = msg.sender
            data[1] = msg.value
            ret = msg(tx.gas - 25, market[3], msg.value, data, 2) # "Updating BalancesContract (XETH)"
            # return(market[3])
            return(1)

        #
        # Withdrawal
        #
        elif msg.data[0] == 5: // "WITHDRAW"
            market = array(4)
            marketid = msg.data[2]

            # Get market
            market = call(markets, [marketid], 1, 4)

            data = array(3)
            data[0] = msg.sender
            data[1] = msg.data[1]
            data[2] = 2
            ret = call(market[3], data, 3)
            return(ret)

        #
        # Cancelation
        #
        elif msg.data[0] == 6: // "CANCEL"
            # owner = contract.storage[2]
            # suicide(msg.sender)
            return(0) // "Not implemented yet"

        #
        # Add market
        #
        elif msg.data[0] == 7: // "ADDMARKET"
            # if msg.value < 10 ^ 18:
            #     if msg.value > 0: # "Refunding"
            #         ret = send(msg.sender, msg.value)
            #     return(0) # "Insufficient deposit to add market"

            markets = contract.storage[6]
            market = array(5) // "TODO - Check data..."
            market[0] = 1
            market[1] = msg.data[3]
            market[2] = amount
            market[3] = price
            market[4] = msg.data[4]
            res = call(markets, market, 5) // "Updating CurrenciesContract"

            # Store last count
            contract.storage[7] = res

            # Issue XETH to market creator
            # data = array(2)
            # data[0] = msg.sender
            # data[1] = msg.value
            # ret = call(contract.storage[3], msg.value, data, 2)

            if res:
                return(42) // "Market added"
            else:
                return(41) // "Error adding market"

        #
        # Change ownership
        #
        elif msg.data[0] == 8 and msg.sender == owner:
            contract.storage[15] = msg.data[1] // "Set owner to %s" % msg.data[1]
            return(msg.data[1])

        #
        # Change XETH ownership
        #
        elif msg.data[0] == 9 and msg.sender == owner:
            contract.storage[3] = msg.data[1] // "Set Balances owner to %s" % msg.data[1]
            return(msg.data[1])

        #
        # Edit market
        #
        elif msg.data[0] == 10:
            return(0) // "Not implemented yet"

        #
        # "Input out of range"
        #
        elif msg.data[0] > 10:
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(9) // "Protect the citizens"
            # suicide(msg.sender) // "Protect the citizens"

        #
        # Uncaught operation
        #
        else:
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(0) // "Protect the citizens"

        #
        # Return
        #
        if amount == 0:
            if msg.value > 0: // "Refunding"
                ret = send(msg.sender, msg.value)
            return(20)
        else:
            if !ret:
                ret = 20
            return(ret) // "Order placed"

    #
    # Post-creation init
    #
    elif msg.sender == owner:

        contract.storage[3] = msg.data[0] // "BalancesContract (XETH)"
        contract.storage[4] = msg.data[1] // "IndexesContract"
        contract.storage[5] = msg.data[2] // "TradesContract"
        contract.storage[6] = msg.data[3] // "CurrenciesContract (markets), storage # 7 for count"

        # NameReg
        call(msg.data[4], 0x4574686572457800000000000000000000000000000000000000000000000000) # EtherEx

        # Set contract as active
        contract.storage[1] = 1

        return(1) // "EtherEx initialized"
