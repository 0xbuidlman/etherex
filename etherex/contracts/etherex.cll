if tx.value < 1000 * block.basefee:
    stop // "Insufficient fee"
status = contract.storage[5000]
if status == 1:
    if tx.datan < 1:
        stop // "No data to process"
    if tx.data[0] < 1 or tx.data[0] > 5:
        stop // "Invalid operation"
    if tx.data[0] < 3:
        if tx.datan < 2:
            stop // "Missing amount"
        elif tx.data[1] < 1:
            stop // "Invalid amount"
        elif tx.datan < 3:
            stop // "Missing price"
        elif tx.data[2] < 1 * 10 ^ 8:
            stop // "Invalid price"
        elif tx.datan < 4:
            stop // "Missing market ID"
        elif tx.data[3] < 1 or tx.data[3] > 1:
            stop // "Invalid market ID"
    amount = tx.data[1] // "Trade amount: %d" % amount
    price = tx.data[2] // "Trade price: %d" % price
    if amount > 256^256 or price > 256^256 or tx.datan > 4:
        stop // "Values out of range"
    markets = contract.storage[5002]
    if tx.data[0] > 0 and tx.data[0] < 3:
        mk = tx.data[3] - 1
        market = markets[mk]
        if mk == 0: // "Verifing minimum trade amounts..."
            if tx.data[0] == 1 and amount < market[1]: // "TODO - Check BTC balances"
                stop // "Minimum BTC trade amount not met, minimum is %s, got %d" % (market[1], amount)
            if tx.data[0] == 2 and tx.value < market[2]: // "TODO - Check XETH balances"
                stop // "Minimum ETH trade amount not met, minimum is %s, got %d" % (market[2], tx.value)
            hk = price // "Trade amounts OK for %s" % market[0]
            book = contract.storage[hk] // "Current price orderbook: %s" % book
            if book == 0:
                book = array(2)
                book[0] = 2
                book[1] = 1
            else:
                book[0] = book[0] + 1
                book[1] = book[1] + 1
            bookadd = array(5)
            bookadd[0] = tx.data[0]
            bookadd[1] = price
            bookadd[2] = amount
            bookadd[3] = tx.sender
            bookadd[4] = mk
            ba = array(1)
            ba[0] = bookadd
            booknonce = book[0]
            booklength = book[1]
            if book[booknonce - 1] == 0: // "Last trade filled, replacing empty data"
                booknonce = booknonce - 1
                book[0] = book[0] - 1
                book[booknonce] = bookadd
            else:
                book = book + ba
            contract.storage[hk] = book // "Trade added, checking price indexes"
            indexes = contract.storage[5003]
            index = indexes[mk] // "Indexed prices: %s" % index
            indexcount = index[0]
            priceindexed = 0
            replaceindex = 0
            tradeat = array(2)
            tradeat[0] = 1
            tradeat[1] = price
            bestprice = price
            ir = 0
            ik = 0
            while indexcount > 0:
                ik = indexcount
                priceindex = index[indexcount] // "Current index: %s" % priceindex
                if priceindex == 0:
                    indexcount = indexcount - 1
                    replaceindex = indexcount
                else:
                    indexedprices = priceindex[0]
                    currentprice = priceindex[1]
                    if currentprice == 0:
                        indexcount = indexcount - 1
                    elif currentprice == price: // "Price already indexed @ %d %s at index %d" % (currentprice / (1 * 10 ** 8), market[0], indexcount)
                        priceindex[0] = indexedprices + 1
                        index[indexcount] = priceindex
                        indexes[mk] = index
                        contract.storage[5003] = indexes
                        ik = indexcount
                        priceindexed = 1
                        indexcount = 0
                    else:
                        if tx.data[0] == 1 and currentprice < price: // "Price index of %s below buy price, checking..." % priceindex[1]
                            if priceindexed == 0:
                                ik = indexcount
                            ir = indexcount
                            addindex = array(1)
                            addindex[0] = currentprice
                            tradeat[0] = tradeat[0] + 1
                            tradeat = tradeat + addindex
                        if tx.data[0] == 2 and priceindex[1] > price: // "Price index of %s above sell price, checking..." % priceindex[1]
                            if priceindexed == 0:
                                ik = indexcount
                            ir = indexcount
                            addindex = array(1)
                            addindex[0] = priceindex[1]
                            tradeat[0] = tradeat[0] + 1
                            tradeat = tradeat + addindex
                indexcount = indexcount - 1
            if priceindexed == 0: // "Indexing new price"
                newindex = array(2)
                newindex[0] = 1
                newindex[1] = price
                newaindex = array(1)
                newaindex[0] = newindex
                if replaceindex > 0: // "Replacing price index %d from %s with %s" % (replaceindex, indexes, newindex)
                    index[replaceindex] = newaindex
                    indexes[mk] = index
                else: // "Adding price index %s to %s" % (newindex, indexes)
                    index[0] = index[0] + 1
                    indexes[mk] = index + newaindex
                contract.storage[5003] = indexes
            while tradeat[0] > 0: // "Indexed prices: %s" % tradeat
                tk = tradeat[0]
                currentprice = tradeat[tk] // "Trading at: %s" % currentprice
                hk = currentprice
                if hk > 0:
                    book = contract.storage[hk]
                if book > 0:
                    booknonce = book[0]
                    booklength = book[1]
                count = 2
                countedall = 0
                while count <= booknonce:
                    curbook = book[count] // "In book @ %s #%d: %s" % (hk, count, curbook)
                    if curbook == 0:
                        count = count + 1
                        countedall = countedall + 1
                    elif countedall > booklength:
                        count = booknonce
                    else:
                        if curbook[4] == mk:
                            if tx.data[0] == 1 and curbook[0] == 2:
                                if amount < curbook[2]: // "Buying %d from balance of %d from %s" % (amount, curbook[2], curbook[3])
                                    curbook[2] = curbook[2] - amount
                                    amount = 0
                                elif amount >= curbook[2]: // "Buying balance of %d from %s" % (curbook[2], curbook[3])
                                    amount = amount - curbook[2]
                                    bookadd[2] = amount
                                    book[count] = bookadd
                                    book[1] = booklength - 1
                                    curbook = 0
                                book[count] = curbook // "Amount left to process: %d in %s" % (amount, book)
                                if amount == 0: // "Trade processed, executing - TODO"
                                    book[1] = book[1] - 1
                                    book[booknonce] = 0
                                    count = booknonce
                                lowerindex = 1 // "Last index: %s" % index
                                if curbook == 0 and amount == 0:
                                    lowerindex = 2
                                if ik <= index[0]:
                                    priceindex = index[ik]
                                    priceindex[0] = priceindex[0] - lowerindex
                                    if priceindex[0] == 0:
                                        index[ik] = 0
                                    else:
                                        index[ik] = priceindex
                                if ir > 1:
                                    priceindex = index[ir] // "and %s" % priceindex
                                    priceindex[0] = priceindex[0] - 1
                                    if priceindex[0] == 0:
                                        index[ir] = 0
                                    else:
                                        index[ir] = priceindex
                                indexes[mk] = index // "Updating index key %d with %s" % (tk, index)
                                contract.storage[5003] = indexes
                                contract.storage[hk] = book
                            elif tx.data[0] == 2 and curbook[0] == 1:
                                if amount > curbook[2]: // "Selling %d from balance of %d to %s" % (curbook[2], amount, curbook[3])
                                    amount = amount - curbook[2]
                                    bookadd[2] = amount
                                    book[count] = bookadd
                                    book[1] = booklength - 1
                                    curbook = 0
                                elif amount <= curbook[2]: // "Selling balance of %d to %s" % (amount, curbook[3])
                                    curbook[2] = curbook[2] - amount
                                    book[1] = booklength - 1
                                    amount = 0
                                    if curbook[2] == 0:
                                        curbook = 0
                                        book[1] = booklength - 1
                                book[count] = curbook // "Amount left to process: %d" % amount
                                if amount == 0: // "Trade processed, executing"
                                    book[1] = book[1] - 1
                                    book[booknonce] = 0
                                    count = booknonce
                                lowerindex = 1
                                if curbook == 0 and amount == 0:
                                    lowerindex = 2
                                if ik <= index[0]:
                                    priceindex = index[ik] // "Updating index %s from key %d by minus %d" % (priceindex, ik, lowerindex)
                                    priceindex[0] = priceindex[0] - lowerindex
                                    if priceindex[0] == 0:
                                        index[ik] = 0
                                    else:
                                        index[ik] = priceindex
                                if ir > 1:
                                    priceindex = index[ir] // "and %s" % priceindex
                                    priceindex[0] = priceindex[0] - 1
                                    if priceindex[0] == 0:
                                        index[ir] = 0
                                    else:
                                        index[ir] = priceindex
                                indexes[mk] = index
                                contract.storage[5003] = indexes
                                contract.storage[hk] = book
                        count = count + 1
                        countedall = countedall + 1
                    tradeat[0] = tradeat[0] - 1
                count = 3
                countedall = 0
                while count <= booknonce:
                    curbook = book[count]
                    if curbook == 0 and count < booknonce:
                        left = booknonce - count
                        if left > 0:
                            countshift = count + 1
                            while left > 0 and book[countshift] == 0:
                                left = left - 1
                                countshift = countshift + 1
                            totalshift = countshift - count + 1
                            book[totalshift] = book[countshift] // "Shifting records of empty book index # %s with %d left by %d" % (count, booknonce - count, totalshift)
                            book[count + 1] = 0
                            book[0] = book[0] - totalshift
                            contract.storage[hk] = book
                    elif countedall > booklength:
                        count = booknonce
                    count = count + 1
                    countedall = countedall + 1
            tradeat[0] = tradeat[0] - 1
    elif tx.data[0] == 3: // "DEPOSIT"
        stop // "Not implemented yet"
    elif tx.data[0] == 4: // "WITHDRAW"
        stop // "Not implemented yet"
    elif tx.data[0] == 5: // "CANCEL"
        stop // "Not implemented yet"
    else:
        stop // "Protect the citizens"
    if amount == 0:
        stop // "TODO - Execute trades"
    else:
        stop // "Order placed"
else:
    owners = array(3)
    owners[0] = 0xb5b8c62dd5a20793b6c562e002e7e0aa68316d31 // define 0xb5b8c62dd5a20793b6c562e002e7e0aa68316d31=CAK
    owners[1] = 0xec2be90307254c5540453419282add242c177941 // define 0xec2be90307254c5540453419282add242c177941=EOAR
    owners[2] = 0x4272203a4343e0edf81eff450bd0f305fd2a3965 // define 0x4272203a4343e0edf81eff450bd0f305fd2a3965=FAB
    markets = array(2)
    marketa = array(3)
    indexes = array(2)
    marketa[0] = "ETH/BTC"
    marketa[1] = 1 * 10 ^ 7 // "Minimum mBTC trade: %d" % (marketa[1] / (10 ** 5))
    marketa[2] = 1 * 10 ^ 19 // "Minimum ETH trade: %d" % (marketa[2] / (10 ** 18))
    ia = array(1)
    ia[0] = 0
    marketb = array(3)
    marketb[0] = "ETH/XETH"
    marketb[1] = 1 * 10 ^ 19 // "Minimum XETH trade: %d" % (marketb[1] / (10 ** 18))
    marketb[2] = 1 * 10 ^ 19
    ib = array(1)
    ib[0] = 0
    indexes[0] = ia
    indexes[1] = ib
    markets[0] = marketa
    markets[1] = marketb
    contract.storage[5001] = owners
    contract.storage[5002] = markets
    contract.storage[5003] = indexes
    contract.storage[5004] = tx.value / 3 // "ETH base funds: %d ETH" % ((tx.value / 3) / 10 ** 21)
    contract.storage[5005] = tx.value / 3 // "ETH running funds: %d ETH" % ((tx.value / 3) / 10 ** 21)
    contract.storage[5006] = tx.value / 3 // "XETH running funds: %d XETH" % ((tx.value / 3) / 10 ** 21)
    contract.storage[5000] = 1
    stop // "EtherEx initialized"
