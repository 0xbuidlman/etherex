# balances.se -- Ethereum contract
#
# Copyright (c) 2014 EtherEx
#
# This software may be modified and distributed under the terms
# of the MIT license.  See the LICENSE file for details.

#
# Balances (XETH)
#

init:
    contract.storage[2] = msg.sender

code:
    # Basic gas check
    if tx.gas < 1000:
        return(0) // "Insufficient gas"

    # Set our status
    status = contract.storage[1]

    # Set reference to exchange
    exchange = contract.storage[2]

    # Logging
    contract.storage[20] = msg.datasize
    contract.storage[21] = tx.gas

    if status == 1: // "Running contract..."

        balance = contract.storage[msg.sender] // "Balance of %s: %d" % (msg.sender, balance)

        if msg.value > 0: // "Transfering value to XETH: %s" % msg.value
            balance = balance + msg.value
            contract.storage[msg.sender] = balance

        # Get our inputs
        to = msg.data[0]
        value = msg.data[1]

        # Check our inputs for transfers
        if msg.datasize < 3:
            if to < 100:
                return(2) // "msg.data[0] out of bounds: %s" % to
            if value < 1:
                return(3) // "msg.data[1] out of bounds: %s" % value

        # Check for sufficient funds and adjust balances
        if balance < value:
            return(4) // "Insufficient funds, %s has %d needs %d" % (msg.sender, balance, value)

        elif value > 0: // "Adjusting values by %d" % value
            balance = contract.storage[msg.sender] - value
            contract.storage[msg.sender] = balance
            contract.storage[to] = contract.storage[to] + value

        # Operations
        if msg.datasize == 3:

            # Check balance
            if msg.data[2] == 1:
                ret = contract.storage[to] // "Balance of %s: %s" % (to, ret)
                return(ret)

            # Withdraw
            elif msg.data[2] == 2: // "Withdraw"
                if msg.sender == contract.storage[2]:
                    balance = contract.storage[msg.data[0]]
                    if balance < value:
                        return(0) // "Insufficient funds, %s had %d, needed %d" % (msg.data[0], balance, value)
                elif balance < value:
                    return(0) // "Insufficient funds, %s has %d needs %d" % (msg.sender, balance, value)
                contract.storage[msg.sender] = contract.storage[msg.sender] - value
                send(tx.gas / 2, msg.data[0], value)
                return(1)

            # Check ownership
            elif msg.data[2] == 3: // "Checking ownership"
                owner = contract.storage[2]
                isowner = 0
                if to == owner: // "Checking %s against %s" % (to, owner)
                    isowner = owner
                return(owner)

            # Add to balance
            elif msg.data[2] == 4 and msg.sender == exchange: // #define 0x45746865724578=EX
                if value < 1 or value > 1 * 10 ^ 18:
                    return(0)
                contract.storage[to] = contract.storage[to] + value // "Minting %d" % value

            # Change ownership
            elif msg.data[2] == 5 and msg.sender == contract.storage[2]:
                contract.storage[2] = msg.data[1]
                return(0) // "Set owner to %s" % msg.data[1]

        return(1)

    elif msg.sender == exchange:
        n = 3
        owners = array(n)
        owners[0] = 0xb5b8c62dd5a20793b6c562e002e7e0aa68316d31 // #define 0xb5b8c62dd5a20793b6c562e002e7e0aa68316d31=ALICE
        owners[1] = 0xe559de5527492bcb42ec68d07df0742a98ec3f1e // #define 0xe559de5527492bcb42ec68d07df0742a98ec3f1e=BOB
        owners[2] = 0xf9e57456f18d90886263fedd9cc30b27cd959137 // #define 0xf9e57456f18d90886263fedd9cc30b27cd959137=CHARLIE

        # Split endowment between owners
        i = 0
        while i < n:
            contract.storage[owners[i]] = msg.value / n
            i = i + 1

        contract.storage[msg.sender] = msg.value # DEBUG - Set full value to sender

        # Set contract owner
        contract.storage[2] = msg.data[0]

        # Set contract as active
        contract.storage[1] = 1 // "Initializing storage for creators %s" % owners

        return(1)
